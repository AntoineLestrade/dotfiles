" vim: set foldmethod=marker et sts=4 sw=4:
let g:is_nvim = has('nvim')
" Switches {{{
let g:enable_cursorline = 0
let g:echo_startup_time = 1
let g:enable_completion = has('lua') && !g:is_nvim

let g:has_persistent_undo = has('persistent_undo')
" }}}

" Startup {{{
if g:echo_startup_time && has('vim_starting') && has('reltime')
    let s:startuptime = reltime()
    autocmd VimEnter * let s:startuptime = reltime(s:startuptime) | redraw | echomsg 'startuptime: ' . reltimestr(s:startuptime)
endif
" }}}
if filereadable($HOME.'/_vimrc.before')
    source $HOME/_vimrc.before
endif
" Initialization {{{
let g:is_windows = has('win32') || has('win64')
if g:is_nvim
    if g:is_windows
        if $XDG_CONFIG_HOME
            let g:rc_dir = $XDG_CONFIG_HOME.'/nvim'
        else
            let g:rc_dir = $APPDATA.'/nvim'
        endif
        let $CACHE = $HOME.'/nvimcache'
    else
        let g:rc_dir = $HOME.'/.nvim'
        let $CACHE = $HOME.'/.nvimcache'
    endif
else
    set nocompatible
    if g:is_windows
        let g:rc_dir = $HOME.'/vimfiles'
        let $CACHE = $HOME.'/vimcache'
    else
        let g:rc_dir = $HOME.'/.vim'
        let $CACHE = $HOME.'/.vimcache'
    endif
endif
" }}} Initialization
" Vimplug {{{
silent! if plug#begin($CACHE.'/plugged')

Plug 'mattn/emmet-vim'
" ## Development {{{
Plug 'scrooloose/syntastic'
" #### Powershell {{{
Plug 'PProvost/vim-ps1'
" #### }}}
" #### Rust {{{
Plug 'rust-lang/rust.vim', { 'for': 'rust' } " {{{
let g:rust_fold = 1
let g:ftplugin_rust_source_path = 'D:/ProgramFiles/Rust_src/src'
" }}}
" }}}
" #### SQL {{{
Plug 'sqlserver.vim', { 'for': 'sql' }
" #### }}}
" #### Git {{{
Plug 'tpope/vim-fugitive'
Plug 'rhysd/committia.vim'
Plug 'airblade/vim-gitgutter'

Plug 'gregsexton/gitv', { 'on': 'Gitv' }
" #### }}}
" ## }}}
" ## User interface {{{
Plug 'w0ng/vim-hybrid'
Plug 'chriskempson/base16-vim'
Plug 'altercation/vim-colors-solarized'
Plug 'itchyny/lightline.vim' " {{{
set laststatus=2
set noshowmode
" let g:lightline = {... {{{
let g:lightline = {
\   'colorscheme': 'jellybeans',
\   'active': {
\       'left': [
\           ['mode', 'paste'],
\           ['git_changes', 'readonly', 'fugitive'],
\           ['ctrlpmark', 'filename']
\       ],
\       'right': [
\           ['lineinfo'],
\           ['percent'],
\           ['fileformat', 'fileencoding', 'filetype', '#warningmsg#', 'syntastic', '*']
\       ]
\   },
\   'component': {
\       'paste': '%{&paste?"!":""}'
\   },
\   'component_function': {
\     'mode'         : 'MyMode',
\     'git_changes'  : 'MyGitGutterStatus',
\     'fugitive'     : 'MyFugitive',
\     'filename'     : 'MyFilename',
\     'readonly'     : 'MyReadonly',
\     'ctrlpmark'    : 'CtrlPMark',
\     'bufferline'   : 'MyBufferline',
\     'fileformat'   : 'MyFileformat',
\     'fileencoding' : 'MyFileencoding',
\     'filetype'     : 'MyFiletype'
\   },
\   'component_expand': {
\       'syntastic': 'SyntasticStatuslineFlag',
\   },
\   'component_type': {
\       'syntastic': 'middle',
\   },
\   'subseparator': {
\       'left': '|', 'right': '|'
\   }
\ }
" }}}
" let g:lighline.mode_map = {... {{{
let g:lightline.mode_map = {
    \ 'n'      : ' N ',
    \ 'i'      : ' I ',
    \ 'R'      : ' R ',
    \ 'v'      : ' V ',
    \ 'V'      : 'V-L',
    \ 'c'      : ' C ',
    \ "\<C-v>" : 'V-B',
    \ 's'      : ' S ',
    \ 'S'      : 'S-L',
    \ "\<C-s>" : 'S-B',
    \ '?'      : '      ' } " }}}
function! MyModified() " {{{
    return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction " }}}
function! MyFilename() " {{{
    let fname = expand('%:t')
    let mod = MyModified()
    return fname == 'ControlP' ? g:lightline.ctrlp_item :
                \ fname == '__Tagbar__' ? g:lightline.fname :
                \ fname =~ '__Gundo\|NERD_tree' ? '' :
                \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
                \ &ft == 'unite' ? unite#get_status_string() :
                \ &ft == 'vimshell' ? vimshell#get_status_string() :
                \ ('') .
                \ ('' != fname ? fname : '[No Name]') .
                \ ('' != mod ? ' ' . mod : '')
endfunction " }}}
function! MyMode() " {{{
    let fname = expand('%:t')
    return fname == '__Tagbar__' ? 'Tagbar' :
                \ fname == 'ControlP' ? 'CtrlP' :
                \ winwidth('.') > 60 ? lightline#mode() : ''
endfunction " }}}
function! MyGitGutterStatus() " {{{
    if !exists('GitGutterGetHunxSummary')
        return ''
    endif
    let hunks = GitGutterGetHunkSummary()
    let symbols = ['+', ' ~', ' -']
    if empty(hunks) || !exists('*fugitive#head') || !strlen(fugitive#head())
        return ''
    else
        let res = ''
        for i in [0, 1, 2]
            let res .= symbols[i] . hunks[i]
        endfor
        return res
    endif
endfunction " }}}
function! MyFugitive() " {{{
    try
        if expand('%:t') !~? 'Tagbar' && exists('*fugitive#head')
            "let mark = '± '
            let _ = fugitive#head()
            "return strlen(_) ? mark._ : ''
            return _
        endif
    catch
    endtry
    return ''
endfunction " }}}
function! MyReadonly() " {{{
    return &ft !~? 'help' && &readonly ? '≠' : '' " or ⭤
endfunction " }}}
function! CtrlPMark() " {{{
    if expand('%:t') =~ 'ControlP'
        call lightline#link('iR'[g:lightline.ctrlp_regex])
        return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
                    \ , g:lightline.ctrlp_next], 0)
    else
        return ''
    endif
endfunction " }}}
function! MyFileformat() " {{{
    return winwidth(0) > 90 ? &fileformat : ''
endfunction " }}}
function! MyFiletype() " {{{
    return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction " }}}
function! MyFileencoding() " {{{
    if winwidth(0) < 80
        return ''
    endif
    let baseenc = strlen(&fenc) ? &fenc : &enc
    if (&bomb)
        let baseenc = baseenc . ' BOM'
    endif
    return baseenc
endfunction " }}}
augroup AutoSyntastic " {{{
    autocmd!
    autocmd BufWritePost *.c,*.cpp,*.perl,*.py,*rs call s:syntastic()
augroup END " }}}
function! s:syntastic() " {{{
    SyntasticCheck
    call lightline#update()
endfunction " }}}
" lightline.vim }}}
" ## }}}
call plug#end()
endif
"  Vimplug }}}
" Vim settings {{{
filetype plugin indent on

" ## Basic options {{{
set autoread                   " Automatically read file again which has been changed outside of Vim
set backspace=indent,eol,start " Working of <BS>,<Del>,CTRL-W,CTRL-U
set display=lastline
set formatoptions+=j
set hidden                     " Display another buffer when current buffer isn't saved.
set history=1000               " Store a ton of history (default is 20)
set linebreak                  " Vim will wrap long lines at a character in 'breakat'
set mouse=a                    " Automatically enable mouse usage
set mousehide                  " Hide the mouse cursor while typing
set ruler                      " Show the linz and column number of the cursor position. Useless with lightline or something like that
set scrolloff=3                " Lines above/below cursor
set sidescrolloff=5
set splitright                 " Puts new vsplit windows to the right of the current
set splitbelow                 " Puts new split windows to the bottom of the current
" ## }}}
" ## Tab basic settings {{{
set autoindent        " Copy indent from current line when starting a new line
set expandtab         " Use the appropriate number of spaces to insert a <Tab>
set shiftround        " Round indent to multiple of 'shiftwidth'
set smarttab          " When <Tab> pressed in front of a line, insert siftwidth spaces
set shiftwidth=4      " Number of spaces to use for each step of (auto)indent
set softtabstop=4     " Number of spaces that a <Tab> counts for while editing operations
set tabstop=8         " Number of spaces that a <Tab> in the file counts for
set virtualedit=block " Allow cursor to be where there is no actual charecter (in visual block mode)

set pastetoggle=<F12> " Toggle 'paste' mode (can be used in terminal when pasting from other program)
" }}}
" ## Encoding {{{
set encoding=utf-8
if g:is_windows
    set termencoding=latin1
else
    set termencoding=
endif
" }}}
" ## Search basic settings {{{
set incsearch  " Incremental searching
set ignorecase " Ignore case in search patterns
set smartcase  " Override the ignorecase option if the pattern contains upper case
" set hlsearch   " Highlight search patterns, support reloading
" ## }}}
" ## Backup {{{
set backup
" ## }}}
" ## Undo Basic {{{
if g:has_persistent_undo
    set undofile        " auotmatically saves undo history
    set undolevels=1000
    set undoreload=1000 " Save the whole buffer for undo when reloading it
endif
" ## }}}
" ## Wildmenu {{{
set wildmenu
set wildmode=longest:full,full
" ## }}}
" ## Cursorline {{{
if g:enable_cursorline
    augroup cursorLine
        autocmd!
        autocmd CursorMoved,CursorMovedI,WinLeave * setlocal nocursorline
        autocmd CursorHold,CursorHoldI,WinEnter   * setlocal cursorline
    augroup END
endif
" ## }}}
" ## Close help {{{
autocmd filetype help nnoremap <buffer> q <C-w>c
" }}}
" ## Cusrsor posision when opening a file {{{
function! ResetCursorPosition()
    if line("'\"") <= line("$")
        normal! g`"
        return 1
    endif
endfunction

augroup resetCursorPosition
    autocmd!
    autocmd BufWinEnter * call ResetCursorPosition()
augroup END
autocmd FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])
" ## }}}
" ## Trailing whitespaces {{{
function! s:hl_trailing_spaces() " {{{
    highlight! link TrailingSpaces Error
    syntax match TrailingSpaces containedin=ALL /\s\+$/
endfunction " }}}
autocmd BufWinEnter,ColorScheme * call s:hl_trailing_spaces()

command! -range=% RemoveTrailSpace <line1>,<line2>s!\s*$!!g | nohlsearch
command! -range=% RemoveTrailM <line1>,<line2>s!\r$!!g | nohlsearch
" ## }}}
" }}}
" Key bindings {{{
nnoremap ^ :
let mapleader=','

imap jk <Esc>
omap jk <Esc>
cmap jk <Esc>

imap <C-h> <Left>
imap <C-j> <Down>
imap <C-k> <Up>
imap <C-l> <Right>

" Move around windows {{{
nmap <A-h> <C-w>h
imap <A-h> <C-o><C-w>h
nmap <A-j> <C-w>j
imap <A-j> <C-o><C-w>j
nmap <A-k> <C-w>k
imap <A-k> <C-o><C-w>k
nmap <A-l> <C-w>l
imap <A-l> <C-o><C-w>l
" }}}
" Move windows {{{
nmap <C-A-h> <C-w>H
imap <C-A-h> <C-o><C-w>H
nmap <C-A-j> <C-w>J
imap <C-A-j> <C-o><C-w>J
nmap <C-A-k> <C-w>K
imap <C-A-k> <C-o><C-w>K
nmap <C-A-l> <C-w>L
imap <C-A-l> <C-o><C-w>L
" }}}

" ## Folding {{{
nmap <leader>f0 :set foldlevel=0<CR>
nmap <leader>f1 :set foldlevel=1<CR>
nmap <leader>f2 :set foldlevel=2<CR>
nmap <leader>f3 :set foldlevel=3<CR>
nmap <leader>f4 :set foldlevel=4<CR>
nmap <leader>f5 :set foldlevel=5<CR>
nmap <leader>f6 :set foldlevel=6<CR>
nmap <leader>f7 :set foldlevel=7<CR>
nmap <leader>f8 :set foldlevel=8<CR>
nmap <leader>f9 :set foldlevel=9<CR>
" ## }}}

" ## Visual shifting {{
vnoremap < <gv
vnoremap > >gv
" }}

" Save {{{
noremap <C-s> :update<CR>
vnoremap <C-s> <C-c>:update<CR>
inoremap <C-s> <C-o>:update<CR>
" }}}
" }}}

" Colorscheme {{{
if has('vim_starting')
    syntax on
    set background=dark
    set t_Co=256
    if (&t_Co < 256 || !has('gui')) && !g:is_nvim
        " colorscheme base16-default
        colorscheme default
    else
        try
            " colorscheme base16-default
            colorscheme hybrid
        catch
            colorscheme darkblue
        endtry
    endif
endif
" TODO: Test
function! EnableLightTheming () " {{{
    set background=light
    try
        colorscheme solarized
    catch
        colorscheme default
    endtry
    call extend(g:lightline, { 'colorscheme': 'solarized' })
    call lightline#init()
    call lightline#colorscheme()
endfunction " }}}
command! -bang LightTheming call EnableLightTheming()

function! EnableDarkTheming() " {{{
    set background=dark
    try
        colorscheme hybrid
    catch
        colorscheme darkblue
    endtry
    call extend(g:lightline, { 'colorscheme': 'jellybeans' })
    call lightline#init()
    call lightline#colorscheme()
endfunction " }}}
command! -bang DarkTheming call EnableDarkTheming()
" }}} Colorscheme

" Create needed directories {{{
function! s:initialize_directories() " {{{
    let dir_list = { 'backup': 'backupdir', 'views': 'viewdir', 'swap': 'directory' }
    if g:has_persistent_undo
        let dir_list['undo'] = 'undodir'
    endif

    for [dirname, settingname] in items(dir_list)
        let directory = $CACHE . '/' . dirname . '/'
        if exists("*mkdir")
            if !isdirectory(directory)
                call mkdir(directory)
            endif
        endif
        if !isdirectory(directory)
            echo "Warning: Unable to create backup directory: " . directory
            echo "Try: mkdir -p " . directory
        else
            let directory = substitute(directory, " ", "\\\\ ", "g")
            exec "set " . settingname . "=" . directory
        endif
    endfor
endfunction " }}}
call s:initialize_directories()
" }}}

" Finally {{{
if filereadable($HOME.'/_vimrc.last')
    source $HOME/_vimrc.last
endif

" ## Unlet useless variables {{{
unlet g:echo_startup_time
unlet g:has_persistent_undo
" ## }}}

set secure
" }}}

