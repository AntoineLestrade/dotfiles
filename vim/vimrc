" vim: set foldmethod=marker et sts=4 sw=4:
let g:is_nvim = has('nvim')
" Switches {{{
let g:enable_cursorline = 0
let g:echo_startup_time = 1
let g:enable_completion = has('lua') && !g:is_nvim
let g:has_persistent_undo = has('persistent_undo')
" }}}

" Startup {{{
if g:echo_startup_time && has('vim_starting') && has('reltime')
    let s:startuptime = reltime()
    autocmd VimEnter * let s:startuptime = reltime(s:startuptime) | redraw | echomsg 'startuptime: ' . reltimestr(s:startuptime)
endif
" }}}
" Initialization {{{
let g:is_windows = has('win32') || has('win64')
if g:is_nvim
    if g:is_windows
        let g:rc_dir = $HOME.'/_nvim'
        let $CACHE = $HOME.'/nvimcache'
    else
        let g:rc_dir = $HOME.'/.nvim'
        let $CACHE = $HOME.'/.nvimcache'
    endif
else
    if g:is_windows
        let g:rc_dir = $HOME.'/vimfiles'
        let $CACHE = $HOME.'/vimcache'
    else
        let g:rc_dir = $HOME.'/.vim'
        let $CACHE = $HOME.'/.vimcache'
    endif
endif
let s:neobundle_dir = expand('$CACHE/neobundle')
function! s:source_rc(path) " {{{
    execute 'source' fnameescape(expand(g:rc_dir . '/rc/' . a:path))
endfunction " }}}
" }}} Initialization
" Plugins {{{
if !isdirectory(expand($CACHE))
    if g:is_windows
        call mkdir(expand($CACHE))
    else
        call mkdir(expand($CACHE), 'p')
    endif
endif

" ## Initialize
execute 'set runtimepath+='.s:neobundle_dir.'/neobundle.vim'

call neobundle#begin(s:neobundle_dir)
if neobundle#load_cache()
    NeoBundleFetch 'Shougo/neobundle.vim'
    NeoBundle 'Shougo/vimproc.vim', {
                \ 'build': {
                \       'windows': 'tools\\update-dll-mingw',
                \       'cygwin': 'make -f make_cygwin.mak',
                \       'unix': 'make -f make_unix.mak',
                \   }
                \ }

    "call neobundle#load_toml('~/vimfiles/rc/neobundle.toml', { 'lazy':  1 })
    call neobundle#load_toml(expand(g:rc_dir.'/rc/neobundle.toml'))
    NeoBundleSaveCache
endif

call s:source_rc('plugins.vim')

call neobundle#end()
" }}}
" Vim settings {{{
filetype plugin indent on

" ## Basic options {{{
set autoread                   " Automatically read file again which has been changed outside of Vim
set backspace=indent,eol,start " Working of <BS>,<Del>,CTRL-W,CTRL-U
set display=lastline
set formatoptions+=j
set hidden                     " Display another buffer when current buffer isn't saved.
set history=1000               " Store a ton of history (default is 20)
set linebreak                  " Vim will wrap long lines at a character in 'breakat'
set mouse=a                    " Automatically enable mouse usage
set mousehide                  " Hide the mouse cursor while typing
set ruler                      " Show the linz and column number of the cursor position. Useless with lightline or something like that
set scrolloff=3                " Lines above/below cursor
set sidescrolloff=5
set splitright                 " Puts new vsplit windows to the right of the current
set splitbelow                 " Puts new split windows to the bottom of the current
" ## }}}
" ## Tab basic settings {{{
set autoindent        " Copy indent from current line when starting a new line
set expandtab         " Use the appropriate number of spaces to insert a <Tab>
set shiftround        " Round indent to multiple of 'shiftwidth'
set smarttab          " When <Tab> pressed in front of a line, insert siftwidth spaces
set shiftwidth=4      " Number of spaces to use for each step of (auto)indent
set softtabstop=4     " Number of spaces that a <Tab> counts for while editing operations
set tabstop=8         " Number of spaces that a <Tab> in the file counts for
set virtualedit=block " Allow cursor to be where there is no actual charecter (in visual block mode)

set pastetoggle=<F12> " Toggle 'paste' mode (can be used in terminal when pasting from other program)
" }}}
call s:source_rc('encoding.vim')
" ## Search basic settings {{{
set incsearch  " Incremental searching
set ignorecase " Ignore case in search patterns
set smartcase  " Override the ignorecase option if the pattern contains upper case
" set hlsearch   " Highlight search patterns, support reloading
" ## }}}
" ## Backup {{{
set backup
" ## }}}
" ## Undo Basic {{{
if g:has_persistent_undo
    set undofile        " auotmatically saves undo history
    set undolevels=1000
    set undoreload=1000 " Save the whole buffer for undo when reloading it
endif
" ## }}}
" ## Wildmenu {{{
set wildmenu
set wildmode=longest:full,full
" ## }}}
" ## Cursorline {{{
if g:enable_cursorline
    augroup cursorLine
        autocmd!
        autocmd CursorMoved,CursorMovedI,WinLeave * setlocal nocursorline
        autocmd CursorHold,CursorHoldI,WinEnter   * setlocal cursorline
    augroup END
endif
" ## }}}
" ## Close help {{{
autocmd filetype help nnoremap <buffer> q <C-w>c
" }}}
" ## Cusrsor posision when opening a file {{{
function! ResetCursorPosition()
    if line("'\"") <= line("$")
        normal! g`"
        return 1
    endif
endfunction

augroup resetCursorPosition
    autocmd!
    autocmd BufWinEnter * call ResetCursorPosition()
augroup END
autocmd FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])
" ## }}}
" ## Trailing whitespaces {{{
function! s:hl_trailing_spaces() " {{{
    highlight! link TrailingSpaces Error
    syntax match TrailingSpaces containedin=ALL /\s\+$/
endfunction " }}}
autocmd BufWinEnter,ColorScheme * call s:hl_trailing_spaces()
" ## }}}
" }}}
call s:source_rc('mappings.vim')

if 0 " {{{

if g:enable_completion && has("lua")
    Plug 'Shougo/neosnippet.vim'
    Plug 'Shougo/neosnippet-snippets'
    Plug 'Shougo/neocomplete.vim' " {{{
    let g:neocomplete_enable_fuzzy_completion_start_length = 1

            let g:neocomplete#force_overwrite_completefunc = 1
    " }}}
endif

Plug 'kana/vim-textobj-user'
Plug 'thinca/vim-quickrun'
Plug 'osyo-manga/vim-precious' " {{{
let g:markdown_fenced_languages = [
    \  'coffee',
    \  'css',
    \  'erb=eruby',
    \  'javascript',
    \  'js=javascript',
    \  'json=javascript',
    \  'ruby',
    \  'sass',
    \  'xml',
    \  'python',
    \  'vim',
    \]

" }}}

" TO TEST:
Plug 'junegunn/vim-pseudocl'
Plug 'junegunn/vim-oblique'

" neocomplete {
            "let g:neocomplete#use_vimproc = 1
            " Define dictionary.
            "let g:neocomplete#sources#dictionary#dictionaries = {
                        "\ 'default' : '',
                        "\ 'vimshell' : $HOME.'/.vimshell_hist',
                        "\ 'scheme' : $HOME.'/.gosh_completions'
                        "\ }
            " Define keyword.
                let g:neocomplete#keyword_patterns = {}
                let g:neocomplete#keyword_patterns._ = '\h\w*'
            let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
            let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
            let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
            let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
            let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
            let g:neocomplete#sources#vim#complete_functions = {
                    \     'Unite': 'unite#complete_source',
                    \     'VimShell': 'vimshell#complete',
                    \     'VimFiler': 'vimfiler#complete',
                    \ }
            "call neocomplete#custom#source('ultisnips', 'rank', 500)
            " Plugin key-mappings {
                    function! CleverCr()
                        if pumvisible()
                            if neosnippet#expandable()
                                let exp = "\<Plug>(neosnippet_expand)"
                                return exp . neocomplete#close_popup()
                            else
                                return neocomplete#close_popup()
                            endif
                        else
                            return "\<CR>"
                        endif
                    endfunction
                     "<CR> close popup and save indent or expand snippet 
                    imap <expr> <CR> CleverCr()
                     "<C-h>, <BS>: " close popup and delete backword char.
                    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
                 "<TAB>: completion.
                inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
            " }
            " Enable omni completion.
            autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
            autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
            autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
            autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
            autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
            autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
            autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc
            " Enable heavy omni completion.
    " Normal Vim omni-completion {
            " Enable omni-completion.
            autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
            autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
            autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
            autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
            autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
            autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
            autocmd FileType haskell setlocal omnifunc=necoghc#omnifunc
    " }

    " Snippets {
            " Use honza's snippets.
            let g:neosnippet#snippets_directory='~/.vim/neosnippets'
             "Enable neosnippet snipmate compatibility mode
            let g:neosnippet#enable_snipmate_compatibility = 1
             "For snippet_complete marker.
                if has('conceal')
                    set conceallevel=2 concealcursor=i
                endif
             "Enable neosnippets when using go
            let g:go_snippet_engine = "neosnippet"
            " Disable the neosnippet preview candidate window
            " When enabled, there can be too much visual noise
            " especially when splits are used.
            set completeopt-=preview
    " }

call plug#end() " }}}
end

" Create needed directories {{{
function! s:initialize_directories() " {{{
    let dir_list = { 'backup': 'backupdir', 'views': 'viewdir', 'swap': 'directory' }
    if g:has_persistent_undo
        let dir_list['undo'] = 'undodir'
    endif

    for [dirname, settingname] in items(dir_list)
        let directory = $CACHE . '/' . dirname . '/'
        if exists("*mkdir")
            if !isdirectory(directory)
                call mkdir(directory)
            endif
        endif
        if !isdirectory(directory)
            echo "Warning: Unable to create backup directory: " . directory
            echo "Try: mkdir -p " . directory
        else
            let directory = substitute(directory, " ", "\\\\ ", "g")
            exec "set " . settingname . "=" . directory
        endif
    endfor
endfunction " }}}
call s:initialize_directories()
" }}}

" Colorscheme {{{
if has('vim_starting')
    syntax on
    set background=dark
    set t_Co=256
    if (&t_Co < 256 || !has('gui')) && !g:is_nvim
        " colorscheme base16-default
        colorscheme default
    else
        try
            " colorscheme base16-default
            colorscheme hybrid
        catch
            colorscheme darkblue
        endtry
    endif
endif
// TODO: Test
function! EnableLightTheming () " {{{
    set background=light
    try
        colorscheme solarized
    catch
        colorscheme default
    endtry
    call extend(g:lightline, { 'colorscheme': 'solarized' })
    call lightline#init()
    call lightline#colorscheme()
endfunction " }}}
command! -bang LightTheming call EnableLightTheming()

function! EnableDarkTheming() " {{{
    set background=dark
    try
        colorscheme hybrid
    catch
        colorscheme darkblue
    endtry
    call extend(g:lightline, { 'colorscheme': 'jellybeans' })
    call lightline#init()
    call lightline#colorscheme()
endfunction " }}}
command! -bang DarkTheming call EnableDarkTheming()
" }}} Colorscheme

" Finally {{{
if filereadable($HOME.'/_vimrc.last')
    source $HOME/_vimrc.last
endif

" ## Unlet useless variables {{{
unlet g:echo_startup_time
unlet g:has_persistent_undo
" ## }}}

set secure
" }}}

